本题要求计算A/B，其中A是不超过1000位的正整数，B是1位正整数。你需要输出商数Q和余数R，
使得A = B * Q + R成立。
输入格式：
输入在1行中依次给出A和B，中间以1空格分隔。
输出格式：
在1行中依次输出Q和R，中间以1空格分隔。
输入样例：
123456789050987654321 7
输出样例：
17636684150141093474 3

//虽然是简单的题目，坑点也挺多的，我也想了很久。没有公式，按照除法定义做
#include <iostream>
#include <string.h>
using namespace std;
int main() 
{	
	char A[1010];                 //当然用字符串表示
	int B;
	cin >> A >> B;
	int l = strlen(A);            //因为直接在本字符数组操作，要先记下长度信息，不然后面不好获取了
	for (int i = 0; A[i]; ++i)    //字符变数字，直接在字符数组操作没问题
		A[i] = A[i] - '0';
	int t = 0;                    //t表示除法过程中的余数
	for (int i = 0; i<l; ++i) {
		int tmp = A[i];             //求余求商2次用到A[i]，直接在数组A修改值的，所以要临时变量把A[i]存下，直接修改A[i]成为余数数组
		A[i] = (tmp + t*10) / B;
		t = (tmp + t*10) % B;
	}
	if (l==1) {                   //如果A比B小，按照第二种方式直接把商0跳过了，所以单独列出来。这种处理方式不优雅，但我暂时没想到其他好办法
		printf("%d", A[0]);
	}
	else {                                  //普适的打印方案，如果第一位是0就跳过不输出。
		for (int i = 0; i < l; ++i) {
			if (i == 0 && A[i] == 0)            //判断条件要注意，必须这样写,要加i==0?的判断，不然条件恒成立
				continue;
			printf("%d", A[i]);
		}
	}
	printf(" %d", t);
}
